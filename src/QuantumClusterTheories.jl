module QuantumClusterTheories

using ExactDiagonalization
using LinearAlgebra
using QuadGK
using QuantumLattices
using Distributed
using TimerOutputs

import QuantumLattices: update, update!

export VCA, singleParticleGreenFunction, spectrum, GrandPotential, OrderParameters

const vcatimer = TimerOutput()
"""
    Perioder{P<:AbstractVector{<:Integer}, T<:AbstractArray{P}, S<:AbstractArray{P}, C<:AbstractVector{<:Tuple}}

The information needed in performing periodic procedure. 
"""
struct Perioder{P<:AbstractVector{<:Integer}, T<:AbstractArray{P}, S<:AbstractArray{P}, C<:AbstractVector{<:Tuple}}
    map₁::T
    map₂::S
    channels::C
end 

"""
    Perioder(unitcell::AbstractLattice, cluster::AbstractLattice, table::Table)

Obtain the periodic information from the lattice system.

WARNING : User should ensure that the cluster you choosed is compatible with the lattice generated by the unitcell you input and the unitcell you input should be enclosed in the cluster you choosed sharing an original point with the cluster.
"""
function Perioder(unitcell::AbstractLattice, cluster::AbstractLattice, table::Table)
    @assert !isempty(unitcell.vectors) "the vectors in unitcell cannot be empty !"
    seq = sort(collect(keys(table)), by = x -> table[x])
    nspin, norbi, channels = sort(collect(Set(key[1] for key in seq))), sort(collect(Set(key[3] for key in seq))), Vector{Tuple{Vector{Int64},Vector{Int64}}}()
    map₁ = [filter(k -> nspin[i]==seq[k][1]&&norbi[j]==seq[k][3], 1:length(seq)) for i in eachindex(nspin), j in eachindex(norbi)]
    map₂ = [filter(j -> issubordinate(cluster.coordinates[:,j]-unitcell.coordinates[:,i], unitcell.vectors), 1:length(cluster)) for i in 1:length(unitcell)]
    for i in 1:size(map₁, 1), j in 1:size(map₁, 2), u in 1:size(map₁, 1), v in 1:size(map₁, 2) 
        push!(channels, ([i, j], [u, v]))
    end
    return Perioder(map₁, map₂, channels)
end

"""
    VCA{L<:AbstractLattice, G<:EDSolver, P<:Perioder} <: Frontend

Variational Cluster Approach(VCA) method for a quantum lattice system.
"""
mutable struct VCA{L<:AbstractLattice, G<:EDSolver, P<:Perioder, T<:Partition} <: Frontend
    const unitcell::L
    const cluster::L
    const origigenerator::OperatorGenerator
    const refergenerator::OperatorGenerator
    solver::G
    const perioder::P
    const parts::T
end

"""
    VCA(sym::Symbol, unitcell::AbstractLattice, cluster::AbstractLattice, hilbert::Hilbert, origiterms::Tuple{Vararg{Term}}, referterms::Tuple{Vararg{Term}}, bs::BinaryBases; neighbors::Union{Nothing, Int, Neighbors}=nothing, m::Int=200)

Construct the Variational Cluster Approach(VCA) method for a quantum lattice system with EDSolver.
"""
function VCA(sym::Symbol, unitcell::AbstractLattice, cluster::AbstractLattice, hilbert::Hilbert, origiterms::Tuple{Vararg{Term}}, referterms::Tuple{Vararg{Term}}, quantumnumbers::Tuple{Vararg{AbelianNumber}}; neighbors::Union{Nothing, Int, Neighbors}=nothing, m::Int=200)
    table = Table(hilbert, Metric(EDKind(hilbert), hilbert))
    isnothing(neighbors) && (neighbors = maximum(term->term.bondkind, origiterms))
    origibonds = bonds(cluster, neighbors)
    perioder = Perioder(unitcell, cluster, table)  
    origigenerator= OperatorGenerator(origiterms, origibonds, hilbert; table = table)
    opencluster = Lattice([cluster.coordinates[:, i] for i in 1:size(cluster.coordinates, 2)]...; name=:opencluster) 
    ed = ED(opencluster, hilbert, referterms, quantumnumbers; neighbors=neighbors)
    edsolver = EDSolver(sym, ed; m = m)
    return VCA(unitcell, cluster, origigenerator, refergenerator, edsolver, perioder, parts)
end
function update!(vca::VCA, oparams::Parameters, rparams::Parameters)
    update!(vca.origigenerator; oparams...)
    update!(vca.refergenerator; rparams...)
    vca.solver = EDSolver(EDKind(vca.refergenerator.hilbert), vca.parts, vca.refergenerator, vca.parts.sector, vca.refergenerator.table; m = length(vca.solver.lvals[1].abc[1][1]))
    return vca
end
"""
    origiQuadraticTerms!(normal::Bool, om::AbstractMatrix, oops::AbstractVector, oopsseqs::AbstractVector,k::AbstractVector)

Calculate the Hamiltonian's quadratic terms of the original system.
"""
function origiQuadraticTerms!(normal::Bool, om::AbstractMatrix, oops::AbstractVector, oopsseqs::AbstractVector,k::AbstractVector)
    !normal&&(pm = copy(om))
    for i in eachindex(oops)
        seq₁, seq₂, n₁, n₂ = oopsseqs[i][1], oopsseqs[i][2], oopsseqs[i][3], oopsseqs[i][4]
        phase = exp(im*dot(k, icoordinate(oops[i])))
        om[seq₁, seq₂] += oops[i].value*phase
        !normal&&(n₁==2&&n₂==1)&&(pm[seq₁, seq₂] += oops[i].value*(phase'))
    end
    if !normal
        om[Vector(1:(size(om,1)÷2)), Vector(1:(size(om,1)÷2))] /= 2
        om[Vector((size(om,1)÷2+1):size(om,1)), Vector((size(om,1)÷2+1):size(om,1))] = -transpose(pm[Vector(1:(size(om,1)÷2)), Vector(1:(size(om,1)÷2))])/2
        om = 2om
    end
    return om
end

"""
    referQuadraticTerms(normal::Bool, rops::AbstractVector, rm::AbstractMatrix, table::Table)
    
Calculate the Hamiltonian's quadratic terms of the reference system.
"""
function referQuadraticTerms(normal::Bool, rops::AbstractVector, rm::AbstractMatrix, table::Table)
    for rop in rops 
        rop[1].index.iid.nambu==2 ? seq₁=table[rop[1].index'] : seq₁=(table[rop[1].index]+length(table))
        rop[2].index.iid.nambu==1 ? seq₂=table[rop[2].index] : seq₂=(table[rop[2].index']+length(table))
        rm[seq₁, seq₂] += rop.value
    end
    if !normal
        rm[Vector(1:length(table)),Vector(1:length(table))] /= 2
        rm[Vector(length(table)+1:2*length(table)),Vector(length(table)+1:2*length(table))] = -transpose(rm[Vector(1:length(table)),Vector(1:length(table))])
        rm = 2rm
    end
    return rm
end

"""
    seqs(oops::AbstractVector, table::Table)

The index's sequences of original system operators.
"""
function seqs(oops::AbstractVector, table::Table)
    seqs = [zeros(Int, 2) for _ in 1:length(oops)]
    for i in eachindex(oops)
        oops[i][1].index.iid.nambu==2 ? seq₁=table[oops[i][1].index'] : seq₁=(table[oops[i][1].index]+length(table))
        oops[i][2].index.iid.nambu==1 ? seq₂=table[oops[i][2].index] : seq₂=(table[oops[i][2].index']+length(table))
        seqs[i] = [seq₁, seq₂, oops[i][1].index.iid.nambu, oops[i][2].index.iid.nambu]
    end
    return seqs
end

"""
    CPTcore(cgfm::AbstractMatrix, vm::AbstractMatrix)

The calculating core of the CPT method.
"""
function CPTcore(cgfm::AbstractMatrix, vm::AbstractMatrix)
    result = Matrix{ComplexF64}(I, size(vm)...)
    return cgfm*inv(mul!(result, vm, cgfm, -1, 1))
end

"""
    perGreenFunction(normal::Bool, GFm::AbstractMatrix, k::AbstractVector, perioder::Perioder, cluster::AbstractLattice)

Perform the periodic procedure to cluster Green function, obtatined periodization Green function with respect to whole k-space.
"""
function perGreenFunction(normal::Bool, GFm::AbstractMatrix, k::AbstractVector, perioder::Perioder, cluster::AbstractLattice)
    N₁, N₂, P = length(perioder.map₁), length(perioder.map₂), size(GFm, 1)÷2
    normal ? (V = 1) : (V = 4)
    normal ? (bgfv = [GFm]) : (bgfv = [GFm[1:P,1:P], GFm[1:P,(P+1):2P], GFm[(P+1):2P, 1:P], GFm[(P+1):2P, (P+1):2P]])
    gfvs = [Vector{Matrix{ComplexF64}}(undef, length(perioder.channels)) for _ in 1:V]
    pm = periodmatrix(cluster.coordinates, k)
    for i in 1:V
        for j in eachindex(perioder.channels)
            gfvs[i][j] = periodsum(perioder.map₂, bgfv[i][perioder.map₁[perioder.channels[j][1]...], perioder.map₁[perioder.channels[j][2]...]].*pm, N₂, size(cluster.coordinates,2))
        end
    end
    gfmv = [reshapematrix(N₁, N₂, gfv) for gfv in gfvs]
    normal ? (gfm = gfmv[1]) : (gfm = [gfmv[1] gfmv[2]; gfmv[3] gfmv[4]])
    return gfm
end
function periodmatrix(coordinates::AbstractMatrix, k::AbstractVector)
    L = size(coordinates,2)
    pm = Matrix{ComplexF64}(undef, L, L)
    for i in 1:L, j in 1:L
        @views ra, rb = coordinates[:, i], coordinates[:, j]
        pm[i, j] = exp(-im*dot(k, (ra - rb)))
    end
    return pm
end
function periodsum(map₂::AbstractVector, lgfm::AbstractMatrix, N::Int, L::Int)
    pgfm = Matrix{ComplexF64}(undef, N, N)
    for m in 1:N, n in 1:N
        @views cmap₂, hmap₂ = map₂[m], map₂[n]
        pgfm[m, n] = (N/L)*sum(lgfm[cmap₂, hmap₂])
    end
    return pgfm
end
function reshapematrix(N₁::Int, N₂::Int, gfv)
    gfm = Matrix{ComplexF64}(undef, N₁*N₂,  N₁*N₂)
    gfmm = reshape(gfv, (N₁, N₁))
    for i in 1:N₁, j in 1:N₁
        for u in 1:N₂, v in 1:N₂
            gfm[(i-1)*N₂ + u, (j-1)*N₂ + v] = gfmm[i, j][u, v]
        end
    end
    return gfm
end

"""
    GreenFunctionPath(normal::Bool, om::AbstractMatrix, oops::AbstractVector, oopsseqs::AbstractVector, rm::AbstractMatrix, perioder::Perioder, cluster::AbstractLattice, k_path::Union{AbstractVector, ReciprocalSpace}, CGFm::AbstractMatrix)

Give the Green function of a certain path or area in k-space with respect to a certain energy.
"""
function GreenFunctionPath(normal::Bool, om::AbstractMatrix, oops::AbstractVector, oopsseqs::AbstractVector, rm::AbstractMatrix, perioder::Perioder, cluster::AbstractLattice, k_path::Union{AbstractVector, ReciprocalSpace}, CGFm::AbstractMatrix)
    gfpath = Vector{Matrix{ComplexF64}}(undef, length(k_path))
    for i in eachindex(k_path)
        dest = copy(om)
        Vm = origiQuadraticTerms!(normal, dest, oops, oopsseqs, k_path[i]) - rm
        gfpath[i] = perGreenFunction(normal, CPTcore(CGFm, Vm), k_path[i], perioder, cluster)
    end
    return gfpath
end 

"""
    singleParticleGreenFunction(sym::Symbol, vca::VCA, k_path::Union{AbstractVector, ReciprocalSpace}, ω_range::Union{AbstractVector,AbstractRange}; μ::Real=0.0, η::Real=0.05)

The single particle Green function in k-ω space.
"""
function singleParticleGreenFunction(sym::Symbol, vca::VCA, k_path::Union{AbstractVector, ReciprocalSpace}, ω_range::Union{AbstractVector,AbstractRange}; μ::Real=0.0, η::Real=0.05)
    ω_range = ω_range .+ (μ + η*im)
    oops, rops = filter(op -> length(op) == 2, collect(expand(vca.origigenerator))), filter(op -> length(op) == 2, collect(expand(vca.refergenerator)))
    R, N = isempty(filter(op -> op.id[1].index.iid.nambu==op.id[2].index.iid.nambu, collect(rops))), length(vca.refergenerator.table)
    R ? N=N : N=2*N
    oopsseqs = seqs(oops, vca.origigenerator.table)
    rm = referQuadraticTerms(R, rops, zeros(ComplexF64, N, N), vca.refergenerator.table)
    gfpv = [GreenFunctionPath(R, zeros(ComplexF64, N, N), oops, oopsseqs, rm, vca.perioder, vca.cluster, k_path, ClusterGreenFunction(R, sym, vca.solver, ω)) for ω in ω_range]
    return gfpv
end

"""
    spectrum(gfpathv::AbstractVector)

The spectrum of the single particle Green function.
"""
function spectrum(gfpathv::AbstractVector)
    A = zeros(Float64, length(gfpathv), length(gfpathv[1]))
        for i in eachindex(gfpathv)
            for j in eachindex(gfpathv[i])
                A[i, j] = (-1/π) * (tr(gfpathv[i][j])).im
            end
        end
        return A
end

"""
    GPcore(temp::AbstractMatrix, cgfm::AbstractMatrix, vm::AbstractMatrix)

The calculating core of the integrand function of the grand potential.
"""
function GPcore(temp::AbstractMatrix, cgfm::AbstractMatrix, vm::AbstractMatrix)
    result = copy(temp)
    mul!(result, vm, cgfm, -1, 1)
    return log(abs(det(result)))
end

"""
    GPintegrand(normal::Bool, sym::Symbol, solver::EDSolver, temp::AbstractMatrix, vmvec::AbstractVector, ω::Complex)

The integrand function of the grand potential.
"""
function GPintegrand(normal::Bool, sym::Symbol, solver::EDSolver, temp::AbstractMatrix, vmvec::AbstractVector, ω::Complex)
    intra = 0.0
    cgfm = ClusterGreenFunction(normal, sym, solver, ω)
    for i in eachindex(vmvec)          
        intra += GPcore(temp, cgfm, vmvec[i])
    end
    normal ? n=1 : n=0.5
    return intra*n
end 

"""
    GrandPotential(sym::Symbol, vca::VCA, bz::AbstractVector, μ::Real) 

The grand potential for a certain VCA.
"""
function GrandPotential(sym::Symbol, vca::VCA, bz::AbstractVector, μ::Real) 
    oops, rops = filter(op -> length(op) == 2, collect(expand(vca.origigenerator))), filter(op -> length(op) == 2, collect(expand(vca.refergenerator)))
    R, N = isempty(filter(op -> op.id[1].index.iid.nambu==op.id[2].index.iid.nambu, collect(rops))), length(vca.refergenerator.table)
    R ? N=N : N=2*N
    oopsseqs = seqs(oops, vca.origigenerator.table)
    rm = referQuadraticTerms(R, rops, zeros(ComplexF64, N, N), vca.refergenerator.table)
    vmvec = Vector{Matrix{ComplexF64}}(undef,length(bz))
    for i in eachindex(bz)
        vmvec[i] = (origiQuadraticTerms!(R, zeros(ComplexF64, N, N), oops, oopsseqs, bz[i]) - rm)
    end
    R ? (trvm = sum([tr(vmv) for vmv in vmvec])) : (trvm = sum([tr(vmv[1:N÷2,1:N÷2]) - tr(vmv[N÷2+1:N,N÷2+1:N]) for vmv in vmvec]))
    gp = (vca.solver.gse + (1/length(bz))*(- quadgk(x -> GPintegrand(R, sym, vca.solver, Matrix{ComplexF64}(I, N, N), vmvec, x*im+μ), 0, Inf)[1]/π + trvm.re/2))/length(vca.cluster)/length(vca.unitcell)
    return gp
end

"""
Grand potential as a function of varparams.
"""
function GrandPotential(oparams::Parameters, rparams::Parameters, sym::Symbol, vca::VCA, bz::AbstractVector, μ::Real)
    update!(vca, oparams, rparams)
    return GrandPotential(sym, vca, bz, μ) 
end

"""
    OPintegrand(normal::Bool, sym::Symbol, vca::VCA, bz::ReciprocalSpace, iω::Complex, sm::AbstractMatrix, oops::AbstractVector, oopsseqs::AbstractVector, rm::AbstractMatrix, μ::Real)

The integrand function of the order parameter.
"""
function OPintegrand(normal::Bool, sym::Symbol, vca::VCA, bz::ReciprocalSpace, iω::Complex, sm::AbstractMatrix, oops::AbstractVector, oopsseqs::AbstractVector, rm::AbstractMatrix, μ::Real)
    om = zeros(ComplexF64, length(vca.refergenerator.table), length(vca.refergenerator.table))
    cgfm = ClusterGreenFunction(normal, sym, vca.solver, iω+μ)
    intra = 0.0
    for k in bz
        vm = origiQuadraticTerms!(normal, copy(om), oops, oopsseqs, k) - rm
        gfm = CPTcore(cgfm, vm)
        intra += (tr(sm*gfm) - tr(sm)/(iω-1.0)).re
    end
    return intra
end

"""
    OrderParameters(oparams::Parameters, rparams::Parameters, sym::Symbol, vca::VCA, hilbert::Hilbert, bz::ReciprocalSpace, term::Term, μ::Real)

Calculate the order parameter.
"""
function OrderParameters(oparams::Parameters, rparams::Parameters, sym::Symbol, vca::VCA, hilbert::Hilbert, bz::ReciprocalSpace, term::Term, μ::Real)
    update!(vca, oparams, rparams)
    rops = filter(op -> length(op) == 2, collect(expand(vca.refergenerator)))
    R, N = isempty(filter(op -> op.id[1].index.iid.nambu==op.id[2].index.iid.nambu, collect(rops))), length(vca.refergenerator.table)
    R ? N=N : N=2*N
    term.value = convert(typeof(term.value), 1.0)
    sm = referQuadraticTerms(R, collect(expand(term, filter(bond -> isintracell(bond), bonds(vca.cluster, term.bondkind)), hilbert)), zeros(ComplexF64, N, N), vca.refergenerator.table)
    oops = filter(op -> length(op) == 2, collect(expand(vca.origigenerator)))
    oopsseqs = seqs(oops, vca.origigenerator.table)
    rm = referQuadraticTerms(R, rops, zeros(ComplexF64, N, N), vca.refergenerator.table)
    return abs((1/length(bz))*quadgk(x -> OPintegrand(R, sym, vca, bz, x*im, sm, oops, oopsseqs, rm, μ), 0, Inf)[1]/π/length(vca.unitcell)/length(vca.cluster))
end

end #module
